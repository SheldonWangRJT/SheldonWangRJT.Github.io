---
title: 'Swift Dependency Injection (DI) Rant'
date: 2024-12-09
permalink: /posts/2024/12/blog-post-8/
tags:
  - Swift
  - thread-safe
  - DI
---

# Dependency Injection in iOS: Why and How to Use It

Dependency Injection (DI) is a cornerstone of modern app architecture, enabling cleaner, more modular, and testable code. In this post, we'll explore why DI is essential, review popular open-source frameworks, and discuss building a simple DI framework from scratch. We'll also highlight how advanced tools like **Needle** address common challenges in DI implementation.

---

## 1. Why Use Dependency Injection?

Dependency Injection isn't just about managing dependencies—it’s about creating software that is easier to build, test, and maintain. Here’s why it matters:

### **Better Structure and Decoupling**
- Promotes adherence to the **Single Responsibility Principle (SRP)** by decoupling components.
- Dependencies are explicit, reducing hidden interconnections and improving code readability.

### **Improved Testability**
- Mocks or stubs can replace real services during testing, simplifying unit tests and isolating behaviors.

### **Scalability**
- As apps grow, DI ensures dependencies are reusable and modular. Adding or replacing services doesn’t require changes across the app.

### **Consistency and Maintainability**
- Centralized dependency management prevents duplication and ensures consistent behavior across the app.

### **Runtime Flexibility**
- Swap implementations (e.g., production vs. mock services) at runtime with minimal effort.

---

## 2. Key Considerations for Dependency Injection Frameworks

Implementing DI goes beyond simply injecting dependencies. A robust framework must address:

### **Thread Safety**
- Dependencies should be safely accessed in multi-threaded environments, especially in singleton or shared instances.

### **Graph Structure**
- Avoiding circular dependencies and ensuring a clear, hierarchical relationship between components is critical.

### **App Startup Speed**
- Lazy initialization ensures services are instantiated only when needed, improving performance during app startup.

---

## 3. Popular Open-Source DI Frameworks for iOS

Several open-source frameworks simplify DI in iOS, each with unique strengths:

### **1. Needle**
- **Features**: Compile-time safety, scoping, and code generation for minimal boilerplate.
- **Best For**: Large, modular apps requiring precise control over dependency lifetimes.

### **2. Swinject**
- **Features**: Lightweight, flexible, supports assemblies for organized service registration.
- **Best For**: Projects that need runtime DI and flexibility.

### **3. Resolver**
- **Features**: Combines lightweight runtime DI with features like property wrappers and automatic resolution.
- **Best For**: Medium-sized apps where ease of use is a priority.

### **4. Typhoon**
- **Features**: Highly configurable runtime DI framework with advanced features like runtime injection hooks.
- **Best For**: Apps requiring a high degree of runtime customization.

---

## 4. DIY Dependency Injection: Implementing from Scratch

Building a DI framework from scratch not only provides insights into how DI works but also highlights challenges that advanced frameworks like **Needle** address. Here's how to build a simple DI container:

### **Step 1: Basic Container Setup**
We start with a simple dependency container using generics and closures to register and resolve services.

```swift
final class DIContainer {
    static let shared = DIContainer()
    private var services = [String: Any]()

    func register<T>(type: T.Type, isSingleton: Bool = false, factory: @escaping () -> T) {
        let key = String(describing: type)
        if isSingleton {
            services[key] = LazySingleton(factory: factory)
        } else {
            services[key] = factory
        }
    }

    func resolve<T>(type: T.Type) -> T {
        let key = String(describing: type)
        guard let service = services[key] else {
            fatalError("No registered service for \(key)")
        }
        if let singleton = service as? LazySingleton<T> {
            return singleton.instance
        }
        guard let factory = service as? () -> T else {
            fatalError("Invalid factory for \(key)")
        }
        return factory()
    }
}

// Helper for lazy singleton
final class LazySingleton<T> {
    private let factory: () -> T
    private lazy var _instance: T = factory()
    var instance: T { _instance }

    init(factory: @escaping () -> T) {
        self.factory = factory
    }
}
```

### **Step 2: Property Wrappers for Convenience**
Make dependency resolution simpler with `@Injected`.

```swift
@propertyWrapper
struct Injected<T> {
    var wrappedValue: T {
        DIContainer.shared.resolve(type: T.self)
    }
}
```

### **Step 3: Thread Safety and Lazy Initialization**
The singleton implementation in `LazySingleton` ensures that the service is initialized only once when accessed for the first time (lazy initialization). However, for thread safety, especially in multi-threaded scenarios, we can wrap this with a `DispatchQueue` to synchronize access.

```swift
final class LazySingleton<T> {
    private let factory: () -> T
    private var _instance: T?
    private let lock = DispatchQueue(label: "com.di.lazySingleton")

    var instance: T {
        lock.sync {
            if _instance == nil {
                _instance = factory()
            }
            return _instance!
        }
    }

    init(factory: @escaping () -> T) {
        self.factory = factory
    }
}
```

This ensures that no matter how many threads access the service concurrently, the instance will be created safely.

---

### **Why Consider Needle?**

While a DIY DI framework works well for small projects, scaling it to large apps introduces challenges such as:

- **Manual Service Registration**: Managing services across multiple modules becomes cumbersome and error-prone.
- **Compile-Time Safety**: DIY approaches rely on runtime safety, whereas Needle ensures dependencies are resolved at compile time.
- **Complex Scoping**: Managing shared and per-feature services across modules can become complicated.

To address these issues, advanced frameworks like **Needle** provide robust solutions with features like compile-time validation, modular dependency graphs, and automated code generation.

---

### **Needle in Action**

**Defining Components**

Needle organizes dependencies into components, which define the scope and lifetime of services. A parent component provides shared dependencies to its child components.

**Parent Component**:  
```swift
import NeedleFoundation

protocol AppDependency: Dependency {
    var analyticsService: AnalyticsService { get }
}

class AppComponent: BootstrapComponent, AppDependency {
    var analyticsService: AnalyticsService {
        shared { FirebaseAnalyticsService() }
    }
}
```
**Child Component:**:
```swift
import NeedleFoundation

protocol AuthDependency: Dependency {
    var analyticsService: AnalyticsService { get } // Inherited from AppComponent
}

class AuthComponent: Component<AuthDependency> {
    var authService: AuthService {
        shared { AuthServiceImpl() }
    }

    var loginViewModel: LoginViewModel {
        LoginViewModel(authService: authService, analyticsService: dependency.analyticsService)
    }
}
```
At runtime, create and use components like this:
```swift
let appComponent = AppComponent()
let authComponent = AuthComponent(parent: appComponent)

let loginViewModel = authComponent.loginViewModel
let loginVC = LoginViewController(viewModel: loginViewModel)
```

---

### **Code Generation with Needle** ###
Needle includes a build tool to generate dependency code. Add the following build phase to your project:
```
needle generate path/to/Generated/NeedleGenerated.swift
```
The generated code:
- Validates dependency graphs at compile time.
- Automatically wires dependencies between components.
- Reduces boilerplate and ensures consistent dependency injection.

By leveraging Needle, you can build scalable, modular iOS apps with minimal manual dependency management while ensuring compile-time safety and efficient runtime performance.




